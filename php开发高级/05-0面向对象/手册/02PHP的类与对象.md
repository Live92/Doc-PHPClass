[TOC]
## 二、PHP的面向对象

## 1.如何创建一个类

### 1.1 类的声明
> 每个类的定义都以关键字 class 开头，后面跟着类名，后面跟着一对花括号，里面包含有类的属性与方法的定义。 

- 创建类的语法：使用关键字 class 类名 { }

> 注意：遵循PSR4编码规范，类名应该是大驼峰的方式

```php
// 创建类
class ClassName {

}
```


### 1.2 类的属性
- 类里面的变量

```php
class ClassName {
    // 成员属性
    public $name = "萨摩耶";
}

```




### 1.3 类的方法
- 类中的函数

```php
class ClassName {
    // 成员方法
    public function say() {
        echo "汪汪汪~";
    }
}
```



### 1.4 类的常量
- const 常量名 = 值
- 常量的输出和变量输出是不一样的。常量不需要实例化对象，直接由`类名::常量名`

```php
class PageTool {
    const PAGESIZE = 10;
}


```

> 在php中定义常量时，const和define的区别？
```
使用const使得代码简单易读，const本身就是一个语言结构，而define是一个函数。另外const在编译时要比define快很多。

1、const用于类成员变量的定义，一经定义，不可修改。define不可以用于类成员变量的定义，可用于全局常量。

2、const可在类中使用，define()不能

3、const不能再条件语句中定义常量
```


## 2.通过类实例化对象

### 2.1 实例化类
- 实例化对象：使用关键字 new 类名()
```php
// 实例化类，new一个对象
$a = new ClassName();

```

### 2.2 类的调用
- 类成员指向符 ->
- 对象引用 $this，指代当前的对象本身的意思
- 范围解析操作法 ::
  - 范围解析操作符（一对冒号），可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。 
```php
// 1.类内部:访问调用自己的成员属性和成员方法
// 2.类内部:访问调用自己的常量、静态方法
// 3.类内部:子类调用父类的常量、静态犯法

// 1.类外部:访问调用自己的成员属性和成员方法
// 2.类外部:访问调用自己的常量、静态犯法

```

### 2.3 构造方法和析构方法

```
构造方法和析构方法是对象中的两个特殊方法，它们都与对象的生命周期有关。
构造方法是对象被创建完成后第一个被对象自动调用的方法。
析构方法是对象被销毁之前最后一个被对象自动调用的方法。
```
![20200804094205.png](http://img.dinghongchao.top/Typoraimg/20200804094205.png)


- 是默认存在的不去声明它，类会默认存在一个没有参数的列表并且内容
- 构造方法，构造函数 
  - 通常用于初始化任务，比如成员属性赋值
- 析构方法，析构函数
  - 通常用垃圾回收和释放资源，如关闭文件，释放结果集

- 带有双短横线 __的方法都是php本身自带的魔术方法


- 语法：
```php

class  BaseClass  {
    // 构造方法
    function  __construct () {
       print  "开始执行构造方法" ;
    }

    // 析构方法
    function  __destruct () {
       print  "开始执行析构方法" ;
    }
}
```

> 练习：使用构造函数实现一个类的初始化赋值



## 3.类的访问控制


### 3.1 类的访问修饰符

- 什么是访问修饰符

```
用于修饰限定访问权限的标识符号

```

- 访问控制符有哪些？

```
对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。

- public 被定义为公有的类成员可以在任何地方被访问。

- protected 被定义为受保护的类成员则可以被其自身以及其子类和父类访问。

- private 被定义为私有的类成员则只能被其定义所在的类访问。 
```
- 使用方法:访问修饰符 类的成员属性/方法

```php
class BaseClass {
    //  访问修饰符 类的成员属性
    public $name = 'Tom';

    //  访问修饰符 类的成员方法
    public function say(){

    }
}


```
- 访问控制符在内部和子类的访问区别

访问控制/类 | public | protected| private 
---|------|------|---
同一个类中 | √ |  √ |  √
类的子类中|  √ | √ | 
所有的外部成员|  √|  | 



## 4. 其他关键词


### 4.1 static (静态)
- 用 static 关键字来定义静态方法和属性。
- 声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。
- 静态属性不可以由对象通过 -> 操作符来访问。 

- 语法:
```
在类内部访问方式：
self::静态成员属性;
self::静态成员方法();

在类外部访问方式：
类名::静态成员属性;
类名::静态成员方法();

```



```php
class BaseClass {
    //  访问修饰符 类的成员属性
    public static $name = 'Tom';

    //  访问修饰符 类的成员方法
    public static function say(){
        echo 'hi';
    }

    public function hi(){
        echo self::$name;
        self::say();
    }
}

```

### 4.2 final (不可修改)
-  final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。
- final 只能适用于类的成员方法，不能使用于类的成员属性。 



## 4.类的继承

### 4.1 为何要继承父类
- 实现代码的复用性

### 4.2 如何继承一个类？

> 使用extend关键词来实现类的继承，语法：`子类 extend 父类`

```php
class Dog {
    public $name = "狗";
}

class Samoyed extend Dog {
}

```

### 4.3 什么是类的覆盖？
- 所谓覆盖，从本质上来说就是重写。就是当子类继承父类的一些方法后，子类又在其内部定义了相同的方法，则这个新定义的方法会覆盖继承而来的父类的方法，子类只能调用其内部定义的方法。





## 6. 魔术方法

### 6.1 什么是魔术方法？
- 是php内置的，用于在特殊条件下会自动触发的函数.
- 不需要调用，会自动触发。

### 6.2 魔术方法可以用来干什么？
- 为了方便我们在指定的条件下，自动触发实现一些操作用的

>注意： PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀。

### 6.3 用法
- 在需要用到的模式方法的类中直接使用如：

```php
class Test {
    function __魔术方法() {

    }
}
```

### 6.4 常见的魔术方法
```
__construct()  // 构造函数；
类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。

__destruct()， // 析构函数
对象的所有引用都被删除或者当对象被显式销毁时执行。

__call()， 
在对象中调用一个不可访问方法时，__call() 会被调用。 

__callStatic()， 
用静态方式中调用一个不可访问方法时，__callStatic() 会被调用。 

__get()， 
读取不可访问属性的值时，__get() 会被调用。 

__set()， 
在给不可访问属性赋值时，__set() 会被调用。 

__isset()， 
当对不可访问属性调用 isset()  或 empty()  时，__isset() 会被调用。 

__unset()， 
当对不可访问属性调用 unset()  时，__unset() 会被调用。 

__sleep()， 
执行serialize()时，先会调用这个函数

__wakeup()， 
执行unserialize()时，先会调用这个函数

__toString()， 
类被当成字符串时的回应方法

__invoke()，
调用函数的方式调用一个对象时的回应方法 

__set_state()， 
调用var_export()导出类时，此静态方法会被调用。

__clone()，
当对象复制完成时调用

__autoload()，
尝试加载未定义的类

__debugInfo()，
打印所需调试信息


```


## 5 类的重载？

### 5.1 什么是类的重载？
- 重载是类的多态的一种实现。函数重载指一个标识符被用作多个函数名，且能够通过函数的参数个数或参数类型将这些同名的函数区分开来，调用不发生混淆。即当调用的时候，虽然方法名字相同，但根据参数的不同可以自动调用相应的函数。

- PHP本身没不支持重载，但是可以通过魔术方法来实现。后面会详细讲解

```
属性重载
public void  __set ( string $name , mixed  $value )
public mixed  __get ( string $name )
public bool __isset ( string $name )
public void  __unset ( string $name )


方法重载
public mixed  __call ( string $name , array $arguments )
public static mixed  __callStatic ( string $name , array $arguments )

```



## 7. 抽象类和接口

## 8. PHP面向对象中，封装，继承，多态的形式
### 8.1 封装
- PHP类的封装其实就是我们在实例化类来调用它实现特定功能的时候，我们不需要

### 8.2 继承
- PHP类的继承是单一继承，一个子类只能有一个父类。
- 子类重载父类的方法时，其修饰符的级别只能等于或更宽松于父类。

### 8.3 多态
- PHP类的多态性可以由类的覆盖和重载来实现。


## 9. 命名空间
### 9.1 什么是命名空间？
### 9.2 为什么要引入命名空间这个概念？
### 9.3 命名空间的使用
